<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: temporal/api/sdk/v1/task_complete_metadata.proto

namespace Temporal\Api\Sdk\V1;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * Generated from protobuf message <code>temporal.api.sdk.v1.WorkflowTaskCompletedMetadata</code>
 */
class WorkflowTaskCompletedMetadata extends \Google\Protobuf\Internal\Message
{
    /**
     * Internal flags used by the core SDK. SDKs using flags must comply with the following behavior:
     * During replay:
     * * If a flag is not recognized (value is too high or not defined), it must fail the workflow
     *   task.
     * * If a flag is recognized, it is stored in a set of used flags for the run. Code checks for
     *   that flag during and after this WFT are allowed to assume that the flag is present.
     * * If a code check for a flag does not find the flag in the set of used flags, it must take
     *   the branch corresponding to the absence of that flag.
     * During non-replay execution of new WFTs:
     * * The SDK is free to use all flags it knows about. It must record any newly-used (IE: not
     *   previously recorded) flags when completing the WFT.
     * SDKs which are too old to even know about this field at all are considered to produce
     * undefined behavior if they replay workflows which used this mechanism.
     * (-- api-linter: core::0141::forbidden-types=disabled
     *     aip.dev/not-precedent: These really shouldn't have negative values. --)
     *
     * Generated from protobuf field <code>repeated uint32 core_used_flags = 1;</code>
     */
    private $core_used_flags;
    /**
     * Flags used by the SDK lang. No attempt is made to distinguish between different SDK languages
     * here as processing a workflow with a different language than the one which authored it is
     * already undefined behavior. See `core_used_patches` for more.
     * (-- api-linter: core::0141::forbidden-types=disabled
     *     aip.dev/not-precedent: These really shouldn't have negative values. --)
     *
     * Generated from protobuf field <code>repeated uint32 lang_used_flags = 2;</code>
     */
    private $lang_used_flags;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type array<int>|\Google\Protobuf\Internal\RepeatedField $core_used_flags
     *           Internal flags used by the core SDK. SDKs using flags must comply with the following behavior:
     *           During replay:
     *           * If a flag is not recognized (value is too high or not defined), it must fail the workflow
     *             task.
     *           * If a flag is recognized, it is stored in a set of used flags for the run. Code checks for
     *             that flag during and after this WFT are allowed to assume that the flag is present.
     *           * If a code check for a flag does not find the flag in the set of used flags, it must take
     *             the branch corresponding to the absence of that flag.
     *           During non-replay execution of new WFTs:
     *           * The SDK is free to use all flags it knows about. It must record any newly-used (IE: not
     *             previously recorded) flags when completing the WFT.
     *           SDKs which are too old to even know about this field at all are considered to produce
     *           undefined behavior if they replay workflows which used this mechanism.
     *           (-- api-linter: core::0141::forbidden-types=disabled
     *               aip.dev/not-precedent: These really shouldn't have negative values. --)
     *     @type array<int>|\Google\Protobuf\Internal\RepeatedField $lang_used_flags
     *           Flags used by the SDK lang. No attempt is made to distinguish between different SDK languages
     *           here as processing a workflow with a different language than the one which authored it is
     *           already undefined behavior. See `core_used_patches` for more.
     *           (-- api-linter: core::0141::forbidden-types=disabled
     *               aip.dev/not-precedent: These really shouldn't have negative values. --)
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\Temporal\Api\Sdk\V1\TaskCompleteMetadata::initOnce();
        parent::__construct($data);
    }

    /**
     * Internal flags used by the core SDK. SDKs using flags must comply with the following behavior:
     * During replay:
     * * If a flag is not recognized (value is too high or not defined), it must fail the workflow
     *   task.
     * * If a flag is recognized, it is stored in a set of used flags for the run. Code checks for
     *   that flag during and after this WFT are allowed to assume that the flag is present.
     * * If a code check for a flag does not find the flag in the set of used flags, it must take
     *   the branch corresponding to the absence of that flag.
     * During non-replay execution of new WFTs:
     * * The SDK is free to use all flags it knows about. It must record any newly-used (IE: not
     *   previously recorded) flags when completing the WFT.
     * SDKs which are too old to even know about this field at all are considered to produce
     * undefined behavior if they replay workflows which used this mechanism.
     * (-- api-linter: core::0141::forbidden-types=disabled
     *     aip.dev/not-precedent: These really shouldn't have negative values. --)
     *
     * Generated from protobuf field <code>repeated uint32 core_used_flags = 1;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getCoreUsedFlags()
    {
        return $this->core_used_flags;
    }

    /**
     * Internal flags used by the core SDK. SDKs using flags must comply with the following behavior:
     * During replay:
     * * If a flag is not recognized (value is too high or not defined), it must fail the workflow
     *   task.
     * * If a flag is recognized, it is stored in a set of used flags for the run. Code checks for
     *   that flag during and after this WFT are allowed to assume that the flag is present.
     * * If a code check for a flag does not find the flag in the set of used flags, it must take
     *   the branch corresponding to the absence of that flag.
     * During non-replay execution of new WFTs:
     * * The SDK is free to use all flags it knows about. It must record any newly-used (IE: not
     *   previously recorded) flags when completing the WFT.
     * SDKs which are too old to even know about this field at all are considered to produce
     * undefined behavior if they replay workflows which used this mechanism.
     * (-- api-linter: core::0141::forbidden-types=disabled
     *     aip.dev/not-precedent: These really shouldn't have negative values. --)
     *
     * Generated from protobuf field <code>repeated uint32 core_used_flags = 1;</code>
     * @param array<int>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setCoreUsedFlags($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::UINT32);
        $this->core_used_flags = $arr;

        return $this;
    }

    /**
     * Flags used by the SDK lang. No attempt is made to distinguish between different SDK languages
     * here as processing a workflow with a different language than the one which authored it is
     * already undefined behavior. See `core_used_patches` for more.
     * (-- api-linter: core::0141::forbidden-types=disabled
     *     aip.dev/not-precedent: These really shouldn't have negative values. --)
     *
     * Generated from protobuf field <code>repeated uint32 lang_used_flags = 2;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getLangUsedFlags()
    {
        return $this->lang_used_flags;
    }

    /**
     * Flags used by the SDK lang. No attempt is made to distinguish between different SDK languages
     * here as processing a workflow with a different language than the one which authored it is
     * already undefined behavior. See `core_used_patches` for more.
     * (-- api-linter: core::0141::forbidden-types=disabled
     *     aip.dev/not-precedent: These really shouldn't have negative values. --)
     *
     * Generated from protobuf field <code>repeated uint32 lang_used_flags = 2;</code>
     * @param array<int>|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setLangUsedFlags($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::UINT32);
        $this->lang_used_flags = $arr;

        return $this;
    }

}

